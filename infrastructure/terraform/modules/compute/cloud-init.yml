#cloud-config
# Cloud-init configuration with secure vault access and nginx proxy

write_files:
  # Configuration file with all deployment variables
  - path: /opt/deployment/config.env
    permissions: '0644'
    content: |
      PROJECT_NAME=${project_name}
      ENVIRONMENT=${environment}
      BACKEND_REPO_URL=${backend_repo_url}
      BACKEND_BRANCH=${backend_branch}
      VAULT_REPO_URL=${vault_repo_url}
      VAULT_BRANCH=${vault_branch}
      AUTO_UPDATE=${auto_update_enabled}
      VAULT_DEPLOY_KEY_SECRET=${vault_deploy_key_secret_name}
      AWS_REGION=${aws_region}

  # Nginx configuration for FastAPI proxy
  - path: /etc/nginx/sites-available/obsidian-automation
    permissions: '0644'
    content: |
      server {
          listen 80;
          server_name _;

          # Security headers
          add_header X-Frame-Options DENY;
          add_header X-Content-Type-Options nosniff;
          add_header X-XSS-Protection "1; mode=block";

          # API endpoints
          location /api/ {
              proxy_pass http://localhost:8000;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              proxy_read_timeout 300;
              proxy_connect_timeout 300;
              proxy_send_timeout 300;
          }

          # Health check (allow direct access)
          location /api/v1/health {
              proxy_pass http://localhost:8000;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
              access_log off;  # Don't log health checks
          }

          # Documentation endpoints (if needed)
          location /docs {
              proxy_pass http://localhost:8000;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
          }

          location /redoc {
              proxy_pass http://localhost:8000;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto $scheme;
          }

          # Default response for other paths
          location / {
              return 404 '{"error": "Not Found", "message": "This endpoint does not exist"}';
              add_header Content-Type application/json;
          }
      }

  # Main deployment script with secure key handling
  - path: /opt/deployment/deploy.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -euo pipefail

      # Source configuration variables
      # shellcheck source=/dev/null
      source /opt/deployment/config.env

      # Logging function
      log() {
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a /var/log/deployment.log
      }

      # Function to setup SSH key for private repository access
      setup_ssh_key() {
          log "Setting up SSH key for vault repository access..."

          # Create .ssh directory for ubuntu user
          mkdir -p /home/ubuntu/.ssh
          chown ubuntu:ubuntu /home/ubuntu/.ssh
          chmod 700 /home/ubuntu/.ssh

          # Retrieve the deploy key from AWS Secrets Manager
          log "Retrieving deploy key from AWS Secrets Manager..."
          aws secretsmanager get-secret-value \
              --secret-id "$VAULT_DEPLOY_KEY_SECRET" \
              --region "$AWS_REGION" \
              --query SecretString \
              --output text > /home/ubuntu/.ssh/vault_deploy_key

          # Set correct permissions on the private key
          chown ubuntu:ubuntu /home/ubuntu/.ssh/vault_deploy_key
          chmod 600 /home/ubuntu/.ssh/vault_deploy_key

          # Configure SSH to use this key for GitHub vault repository
          cat > /home/ubuntu/.ssh/config << EOF
      Host github.com-vault
          HostName github.com
          User git
          IdentityFile /home/ubuntu/.ssh/vault_deploy_key
          IdentitiesOnly yes
          StrictHostKeyChecking no
      EOF

          chown ubuntu:ubuntu /home/ubuntu/.ssh/config
          chmod 600 /home/ubuntu/.ssh/config

          log "SSH key setup completed"
      }

      # Function to clone repository with SSH key
      clone_vault_with_key() {
          log "Cloning vault repository with deploy key..."

          # Convert HTTPS URL to SSH format with custom host
          VAULT_SSH_URL=$(echo "$VAULT_REPO_URL" | sed 's|https://github.com/|git@github.com-vault:|')

          if [ -d "/opt/vault/.git" ]; then
              log "Vault directory exists, pulling latest changes"
              chown -R ubuntu:ubuntu /opt/vault
              cd /opt/vault
              sudo -u ubuntu git fetch origin
              sudo -u ubuntu git checkout "$VAULT_BRANCH"
              sudo -u ubuntu git pull origin "$VAULT_BRANCH"
          else
              log "Cloning vault from $VAULT_SSH_URL branch $VAULT_BRANCH"
              # Remove existing empty directory if it exists
              rm -rf /opt/vault
              # Clone as ubuntu user into ubuntu's home, then move to /opt
              sudo -u ubuntu git clone -b "$VAULT_BRANCH" "$VAULT_SSH_URL" /home/ubuntu/vault-temp
              mv /home/ubuntu/vault-temp /opt/vault
              chown -R ubuntu:ubuntu /opt/vault
          fi

          log "Vault repository cloned successfully"
      }

      # Function to configure nginx
      setup_nginx() {
          log "Configuring nginx..."

          # Remove default site
          rm -f /etc/nginx/sites-enabled/default

          # Enable our site
          ln -sf /etc/nginx/sites-available/obsidian-automation /etc/nginx/sites-enabled/

          # Test nginx configuration
          nginx -t

          # Reload nginx
          systemctl reload nginx

          log "Nginx configured successfully"
      }

      log "Starting deployment for $PROJECT_NAME in $ENVIRONMENT environment"
      log "Backend: $BACKEND_REPO_URL ($BACKEND_BRANCH)"
      log "Vault: $VAULT_REPO_URL ($VAULT_BRANCH)"

      # Setup SSH key for private vault access
      setup_ssh_key

      # Clone backend repository (public, no special handling needed)
      log "Cloning backend repository..."
      if [ -d "/opt/backend/.git" ]; then
          log "Backend directory exists, pulling latest changes"
          cd /opt/backend
          git fetch origin
          git checkout "$BACKEND_BRANCH"
          git pull origin "$BACKEND_BRANCH"
      else
          log "Cloning backend from $BACKEND_REPO_URL branch $BACKEND_BRANCH"
          git clone -b "$BACKEND_BRANCH" "$BACKEND_REPO_URL" /opt/backend
      fi
      chown -R ubuntu:ubuntu /opt/backend

      # Clone vault repository using deploy key
      clone_vault_with_key

      # Set up application environment file
      log "Creating application environment configuration..."
      cat > /opt/backend/.env << EOF
      ENVIRONMENT=$ENVIRONMENT
      VAULT_PATH=/opt/vault
      GIT_REPO_URL=$VAULT_REPO_URL
      LOG_LEVEL=$([ "$ENVIRONMENT" = "production" ] && echo "WARNING" || echo "DEBUG")
      EOF

      # Configure nginx
      setup_nginx

      # Set up auto-update for development environment
      if [ "$AUTO_UPDATE" = "true" ]; then
          log "Setting up auto-update cron jobs for development"
          cat > /etc/cron.d/auto-update << EOF
      # Auto-update backend and vault every 10 minutes in dev
      */10 * * * * ubuntu cd /opt/backend && git pull origin $BACKEND_BRANCH && docker-compose restart 2>&1 | logger -t auto-update-backend
      */10 * * * * ubuntu cd /opt/vault && sudo -u ubuntu git pull origin $VAULT_BRANCH 2>&1 | logger -t auto-update-vault
      EOF
          log "Auto-update cron jobs configured"
      else
          log "Auto-update disabled for $ENVIRONMENT environment"
      fi

      # Start the application
      log "Starting application with Docker Compose..."
      cd /opt/backend

      # Use the production compose file and fix port mapping
      COMPOSE_FILE="docker-compose.prod.yml"
      if [ ! -f "$COMPOSE_FILE" ]; then
          log "Warning: $COMPOSE_FILE not found, falling back to docker-compose.yml"
          COMPOSE_FILE="docker-compose.yml"
      fi

      if [ -f "$COMPOSE_FILE" ]; then
          # Modify the compose file to use port 8000 instead of 80
          sed -i 's/
